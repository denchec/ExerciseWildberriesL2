package main

import "ExerciseWildberriesL2/Factory/pkg"

var types = []string{pkg.ServerType, pkg.ComputerType, pkg.NotebookType, "mobile"}

func main() {
	for _, typeName := range types {
		machine := pkg.FabricMachine(typeName)
		if machine == nil {
			continue
		}
		machine.PrintDetails()
	}
}

/* Реализация фабричного паттерна в данной программе:
Магазин по продаже компьютеров и подобных им вычислительных машин:
Когда мы получаем тип объекта - передаем его в функцию FabricMachine. Она проверяет, есть ли подобный тип среди
товаров магазина и выводит информацию соответствующую искомому типу.


1) Плюсы:
1.1) Избавляет от привязки к определенному типу объекта(за счет интерфейса поведения)
1.2) Один общий конструктор создания объектов для всех подклассов
1.3) Простота в добавлении новых объектов, без необходимости внесения больших изменений в код
1.4) Реализует принцип открытости и закрытости ?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!
2) Минусы:
2.1) Создание фабричного паттерна может привести к слишком большим и запутанным структурам объектов, которые будут
сложны в сопровождении.
2.2) Фабричный паттерн становится "божественным", через который необходимо будет каждый раз инициализировать
объекты, это может стать проблемой для дальнейшего сопровождения.

3) Фабричный паттерн применяется там, где необходим поиск объектов по каким-либо параметрам(например: код товара,
тип объекта)

4) Реальный пример применения фабричного паттерна:
4.1) Интернет магазины
4.2) Поисковая система на сайтах
4.3) Выгрузка из базы данных*/
