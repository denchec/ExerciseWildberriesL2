package main

import (
	"ExerciseWildberriesL2/Fasad/pkg"
	"fmt"
)

var (
	bank = pkg.Bank{
		Name:  "RandomBank",
		Cards: []pkg.Card{},
	}
	card1 = pkg.Card{
		Name:    "Card-1",
		Balance: 200,
		Bank:    &bank,
	}
	card2 = pkg.Card{
		Name:    "Card-2",
		Balance: 10,
		Bank:    &bank,
	}
	user1 = pkg.User{
		Name: "Покупатель-1",
		Card: &card1,
	}
	user2 = pkg.User{
		Name: "Покупатель-2",
		Card: &card2,
	}
	prod = pkg.Product{
		Name:  "Печеньки",
		Price: 149.99,
	}
	shop = pkg.Shop{
		Name: "Shop24",
		Product: []pkg.Product{
			prod,
		},
	}
)

func main() {
	fmt.Println("[Банк] Выпуск карт")
	bank.Cards = append(bank.Cards, card1, card2)
	fmt.Printf("[%s] Прикладывает карту \n", user1.Name)
	err := shop.Sell(user1, prod.Name)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	fmt.Printf("[%s] Прикладывает карту \n", user2.Name)
	err = shop.Sell(user2, prod.Name)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
}

/* Реализация фасадного паттерна в данной программе:
Оплата товара картой в продуктовом магазине:
Когда покупатель оплачивает товар картой, магазин отправляет сигнал в банк, который выпустил карту,
для получения информации о балансе карты. Когда магазин получает запрошенную информацию, он проверяет, хватает ли
средств для оплаты товара и выводит соответствующий ответ.


Плюсы:
Изолирует клиентов от поведения сложной подсистемы, тем самымм давая пользователю минимум функционала

Минус:
Интерфейс фасада может стать божественным объектом т.е. все последующие функции, в обязательном порядке,
будут проходить через него, что может стать проблемой при дальнейшем сопровождении


3) Фасадный поттерн:
Структурный паттерн проектирования,который предоставляет простой интерфейс к сложной системе
Упрощение интерфейса, для простоты пользования

4) Реальный пример применения фабричного паттерна:
4.1) Оплата картой в терминале
*/
